package com.hexvoid.employeeportal.controller;

import java.util.List;

import com.hexvoid.employeeportal.entity.Employees;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.hexvoid.employeeportal.entity.EmployeeAuthorities;
import com.hexvoid.employeeportal.entity.EmployeeCredentials;
import com.hexvoid.employeeportal.service.EmployeeSecretServiceImpl;


/**
 * The {@code UserController} class handles endpoints related to user authentication,
 * registration, and fetching user details for authenticated users.
 * <p>
 * It is designed to:
 * - Fetch user details after login using a valid JWT token.
 * - Provide admin functionality to fetch user details by email.
 * - Register users with password encryption and authority mapping.
 * </p>
 * <p><b>Security Context:</b></p>
 * <ul>
 *   <li>This controller relies on Spring Security for authentication and authorization.</li>
 *   <li>JWT tokens are used for stateless authentication, and endpoints are protected based on user roles and authorities.</li>
 *   <li>Custom filters such as <code>JWTTokenGeneratorFilter</code> and <code>JWTTokenValidatorFilter</code> handle JWT token generation and validation.</li>
 * </ul>
 */
@RestController
public class UserController {

	private final EmployeeSecretServiceImpl employeeSecretService;
	private final PasswordEncoder passwordEncoder;

	/**
	 * Constructs a {@code UserController} with the specified employee secret service
	 * and password encoder.
	 * 
	 * @param employeeSecretService the service for employee-related operations
	 * @param passwordEncoder       the encoder for password encryption
	 */
	@Autowired
	public UserController(EmployeeSecretServiceImpl employeeSecretService, PasswordEncoder passwordEncoder) {
		this.employeeSecretService = employeeSecretService;
		this.passwordEncoder = passwordEncoder;
	}

	/**
	 * <h2>Endpoint: GET /user/details</h2>
	 * <hr>
	 * <p>
	 * This endpoint returns the details of the authenticated user. Additionally, it generates a new JWT token 
	 * and sends it back to the client in the response header after successful authentication. The request 
	 * itself does not require a JWT token in the header, as the user is already authenticated, and the 
	 * authentication information is provided through Spring Security's SecurityContext.
	 * </p>
	 * <p><b>Key Details:</b></p>
	 * <ul>
	 *   <li><b>JWT Token Generation:</b> The JWT token is generated by the <code>JWTTokenGeneratorFilter</code> 
	 *       after the user is authenticated by Spring Security. The token includes claims like the user's 
	 *       email and authorities.</li>
	 *   <li><b>Authentication:</b> The <code>Authentication</code> object is automatically injected into the 
	 *       method by Spring Security. It contains the user's authentication details, such as the email (used 
	 *       as the username) and authorities.</li>
	 *   <li><b>Response Header:</b> The newly generated JWT token is returned in the response header as 
	 *       <code>Authorization: Bearer &lt;new_JWT&gt;</code>, and the client can store this token for 
	 *       future requests to protected endpoints.</li>
	 * </ul>
	 * 
	 * <p><b>Explanation of the Authentication parameter:</b></p>
	 * The <code>Authentication</code> parameter represents the current authenticated user. It is automatically 
	 * populated by Spring Security and contains:
	 * <ul>
	 *   <li><code>authentication.getName()</code> returns the email of the authenticated user.</li>
	 *   <li>The user's authorities (roles) can be accessed via <code>authentication.getAuthorities()</code>.</li>
	 * </ul>
	 * This information is used to fetch the user details (in this case, <code>EmployeeCredentials</code>) from 
	 * the database.
	 * 
	 * @param authentication The <code>Authentication</code> object provided by Spring Security, which contains 
	 *                       the current user's authentication details, including email and authorities.
	 * 
	 * @return The <code>EmployeeCredentials</code> object corresponding to the authenticated user, or 
	 *         <code>null</code> if no matching user is found.
	 * 
	 * @see org.springframework.security.core.Authentication
	 */
	@RequestMapping("/user/details")
	public EmployeeCredentials getEmployeesDetailsAfterLogin(Authentication authentication) {
		// Fetch user details using the email from the authentication object
		EmployeeCredentials user = employeeSecretService.findByEmail(authentication.getName());
		if (user == null) {
			return null;
		}
		return user;
	}


	/**
	 * <h2>Endpoint: GET /registered/user/findByEmail/{email}</h2>
	 * <p>
	 * This endpoint retrieves a registered user from the database based on their email address.
	 * It is accessible by admin users or for debugging purposes.
	 * The JWT token in the request header is validated by the <code>JWTTokenValidatorFilter</code>
	 * before allowing access to this endpoint.
	 * </p>
	 * 
	 * @param email The email of the user to fetch from the database.
	 * 
	 * @return A {@link ResponseEntity} containing the {@link EmployeeCredentials} object, 
	 *         or a 404 status if the user with the provided email is not found.
	 */
	@GetMapping("/registered/user/findByEmail/{email}")
	ResponseEntity<EmployeeCredentials> findRegisteredUserbyEmail(@PathVariable String email) {

		EmployeeCredentials byEmail = employeeSecretService.findByEmail(email);
		return ResponseEntity.ok(byEmail);
	}

	/**
	 * <h2>Endpoint: POST /register/user</h2>
	 * <p>
	 * This endpoint registers a new user into the system. The user's password is encrypted using the 
	 * <code>PasswordEncoder</code> before storing, ensuring password security.
	 * Additionally, role mapping and the correct establishment of bidirectional relationships between 
	 * {@link EmployeeCredentials} and {@link EmployeeAuthorities} are handled.
	 * </p>
	 * <p><b>Key Details:</b></p>
	 * <ul>
	 *   <li><b>Password Encryption:</b> The user's password is encoded before saving to ensure security.</li>
	 *   <li><b>Authority Mapping:</b> The user's roles and authorities are mapped to establish the relationship 
	 *       between the user and their assigned roles.</li>
	 * </ul>
	 * <p>
	 * The registration process is not dependent on the user's current authentication, 
	 * as the endpoint allows anyone to register as long as the request is valid.
	 * </p>
	 * 
	 * @param employeeCredentials The {@link EmployeeCredentials} object containing the user's details, including 
	 *                            email, password, and roles.
	 * 
	 * @return A {@link ResponseEntity} containing the newly created {@link EmployeeCredentials} object with 
	 *         a 201 status if successful, or a 500 status if an error occurs during the save operation.
	 */
	@PostMapping("/register/user")
	ResponseEntity<EmployeeCredentials> createEmployeeCredentials(@RequestBody EmployeeCredentials employeeCredentials) {

		// Encrypt the user's password before storing
		String pwd = passwordEncoder.encode(employeeCredentials.getPassword());
		employeeCredentials.setPassword(pwd);

		/*
		   Establishing a proper bidirectional relationship between 
		    EmployeeCredentials (Parent) and EmployeeAuthorities (Child) using the helper method inside EmployeeCredentials class.
		    ----------------------------------------------------------------------------------------------------------------------

		   Why is this important?
		 - In JPA/Hibernate, simply adding child entities to the parent’s collection is not enough.
		 - Each child must also explicitly reference its parent to maintain the foreign key relationship.
		 - Without this, Hibernate may leave the foreign key NULL or throw a constraint violation.

		   The helper method associateAuthorities() ensures both sides of the relationship are set correctly:
		 - Parent → Child: the child is added to the parent’s list.
		 - Child → Parent: the parent is set inside the child (foreign key gets mapped properly).

		   Alternatives:
		 - You can use a custom setter like setEmployeeAuthorities() to loop through and set back-references.
		 - For JSON serialization control (not DB mapping), use @JsonManagedReference and @JsonBackReference.

		   Step-by-step:
		 1️ Detach the current list of authorities temporarily.
		 2️ Re-establish the relationship using the helper method associateAuthorities().
		 3️ Save the parent entity — Hibernate will automatically persist the children due to CascadeType.ALL.
		 */

		//		List<EmployeeAuthorities> theEmployeeAuthorityList = employeeCredentials.getEmployeeAuthorities();
		//		employeeCredentials.setEmployeeAuthorities(null);
		//		for (EmployeeAuthorities currentEmployeeAuthority : theEmployeeAuthorityList) {
		//		    employeeCredentials.associateAuthorities(currentEmployeeAuthority);
		//		}

		EmployeeCredentials savedEmployeeCredentials = employeeSecretService.save(employeeCredentials);


		if (savedEmployeeCredentials != null) {
			return new ResponseEntity<>(savedEmployeeCredentials, HttpStatus.CREATED);

		} else {
			return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
		}

	}
}
